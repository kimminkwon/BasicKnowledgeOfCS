# Java

## 1. Java 컴파일 과정
1. 자바 소스코드(`.java`) 작성
2. `자바 컴파일러`에서 해당 소스 파일을 컴파일: 이때, 자바 `바이트 코드파일`(.class)가 생성됨
3. 해당 자바 바이트 코드파일을 `JVM`의 `클래스 로더`에게 전달
4. `클래스 로더`에서 필요한 클래스들을 `JVM`에 올림
5. `실행 엔진`에서 `JVM 메모리`의 바이트 코드들을 명령어 단위로 가져와 실행
  
## 2. JVM(Java Virtual Machine)
* JVM: 자바 가상 머신의 약자
* JVM의 역할
    * 자바 App을 `클래스 로더`로 읽어와 `자바 API`와 함께 실행하는 역할
    * Java와 OS 사이의 중개자 역할: Java가 OS에 구애받지 않고 재사용이 될 수 있음
    * 스택 기반의 가상머신
* JVM을 알야아하는 이유: `JVM`은 Java가 실제 실행되는 과정을 알 수 있게 함, 따라서 메모리 관리 등의 효율성을 고려할 수 있음 
* JVM의 구성
    * 클래스 로더: JVM 내로 `바이트 코드파일`을 로드하는 모듈, 이는 런타임 중에 실행된다.
    * 실행 엔진: `바이트 코드파일`을 명령어 단위로 실행한다.
    * 인터프리터: `실행엔진`내에서 JVM이 실행할 수 있는 인터프리터 언어로 변경한다.
    * JIT(Just In Time): 인터프리터의 특징상 속도가 느리므로, 중복되는 코드를 미리 컴파일하여 속도 향상을 시키는 방법
    
## 3. GC(Garbage Collection)
* Stop-the-wold: `GC`의 실행을 위해 `JVM`이 Java App 실행을 멈추는 것
* Garbage: Heap 내의 객체 중 참조되고 있지 않은 객체를 의미
* GC: 더이상 필요없는 객체(`Garbage`)를 찾아 메모리 할당을 해제하는 작업
    * Young 영역: 새롭게 생성한 객체의 공간, 대부분 금방 접근 불가능 상태가 되어 사라진다(`Minor GC`).
    * Old 영역: `Young 영역`에서 접근 불가능이 되지 않은 객체의 공간, 여기서는 삭제가 잘 일어나지 않음, 일어날 경우 `Major GC`라고 한다.
    * Old 영역에서의 Young 영역 참조: 추가 Table을 두고, Old 영역에서 Young 영역을 참조 시에 이를 Table에 저장한다. 이를 통해 Old 영역의 GC 대상 식별을 효율적으로 할 수 있다.
